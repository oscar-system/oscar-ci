# CI support scripts

The CI depends on a number of support scripts (primarily written in Ruby) to do its work.

# `settings.rb`

This script is used by all other scripts to process environment variables and command line options.

# `prepare.rb`

This script performs pre-installation scripts. In particular, it generates directories and the file `packages.jl` from `config/packages.yaml`, which is later used during installation. Note that like most config files, `config/packages.yaml` is preprocessed through the ERB module first, which allows entries to be generated from Ruby expressions.

# `check-julia-notebook.rb`

This script runs a Julia notebook within the local Jupyter installation and generates structural diffs. These diffs are generated by the `nbdiff` Python script.

# `install/install-julia.rb`

This script installs Julia. It recognizes julia versions that take one of the following formats:

* `download:X.Y.Z`, where `X.Y.Z` is a valid Julia version.
* `tag:tagname` where `tagname` is a tag used by Julia, e.g. `v1.4.2`.
* `branch`, where `branch` is a branchname.

The latter two options will build Julia from source. The goal here is (1) to be able to test against unreleased versions of Julia and (2) to avoid the linking problems with the C++ library that can happen on some platforms.

# `install/install-oscar.rb`

This script installs the Oscar packages; it relies on the Julia script `install/install-oscar.jl`. It has three operation modes (`stable`, `master`, and `develop`) that install different versions of the packages involved. `master` and `develop` differ in the order in which they install packages, either bottom-up or top-down if you follow the dependency graph. These two operation modes are disctinct, as they can lead to differences in how Julia resolves issues.

Any package installation errors are logged to `.pkgerrors` and are later output by the `CheckPackages` test.

# `install/install-jupyter.rb`

This script performs a local installation of `Jupyter`. We specifically want to avoid an installation in the CI user's home directory, where concurrent jobs or tests can conflict with one another. Thus, we're setting 

# `install/install-gap.rb`

This script installs the `gap` executable in the path so that GAP tests can be run.

# `install/install-gap-packages.rb`

This script installs any GAP packages that are not installed through any other process.

# `install/install-finalize.rb`

The finalization script initiates a full precompilation of all installed packages. The goal here is to avoid initialization steps while running tests in parallel, which may not always be free from race conditions.

# `run-tests.rb`

This is where the bulk of the testing happens. This script is responsible for scheduling and running the actual tests as well as uploading the results to GitHub if necessary. GitHub credentials are stored in the file normally specified in `config/jenkins.yaml`. As this script normally runs inside Docker and the file is normally installed as part of the docker installation.

The `TestRunner` class does the major work of running tests. Its operation is straightforward, complicated only by the fact that it has to consider a number of settings for its operation.

Tests are specified in `config/tests.yaml`. See comments in that file for how it is structured and how tests are specified. Tests can have a timeout (which defaults to an hour) to ensure that no test runs endlessly.